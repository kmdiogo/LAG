//
// Created by Kenny on 4/12/2019.
//

#include "Parser.h"

void Parser::parse() {
    if (matchStmtList())
        cout << "Parse Successful" << endl;
    else
        cout << "Parse Unsuccessful" << endl;

}

bool Parser::matchStmtList(){
    cur = getNextToken(file, true);

    if (cur.first == EOI)
        return true;
    else {
        // TODO: Check to see if this is the correct way to check epsilon
        if (!matchStmt()) {
            return false;
        }
        return matchStmtList();
    }
}

bool Parser::matchStmt() {
    if (!matchClassStmt()) {
        if (!matchTokenStmt()) {
            if (!matchIgnoreStmt()) {
                return false;
            }
        }
    }
    return true;
}

bool Parser::matchClassStmt() {
    //cur = getNextToken(file, true);

    if (cur.first != Class) {
        return false;
    }

    cur = getNextToken(file, true);

    if (cur.first != Id) {
        return false;
    }

    cur = getNextToken(file, false);

    if (cur.first != SetStart && cur.first != SetStartNegate) {
        return false;
    }

    cur = getNextToken(file, false);

    if (!matchCItemList()) {
        return false;
    }

    //cur = getNextToken(file, false);

    return (cur.first == SetEnd || cur.first == DashSetEnd);
}

bool Parser::matchCItemList() {
    // TODO: Check to see if this is the correct way to accept epsilon
    if (!matchCItem()) {
        //return false;
        return true;
    }
    return matchCItemList();
}

bool Parser::matchCItem() {
    if (cur.first != Character) {
        return false;
    }

    cur = getNextToken(file, false);

    if (cur.first == Dash) {
        cur = getNextToken(file, false);
        return cur.first == Character;
    }
    else {
        return true;
    }
}

bool Parser::matchTokenStmt() {
    if (cur.first != Token) {
        return false;
    }

    cur = getNextToken(file, true);

    if (cur.first != Id) {
        return false;
    }

    cur = getNextToken(file, false);

    if (cur.first != Slash) {
        return false;
    }

    cur = getNextToken(file, false);

    if (!matchRegex()) {
        return false;
    }

    cur = getNextToken(file, false);

    return cur.first == Slash;
}

bool Parser::matchIgnoreStmt(){
    if (cur.first != Ignore) {
        return false;
    }

    cur = getNextToken(file, false);

    if (cur.first != Slash) {
        return false;
    }

    cur = getNextToken(file, false);

    if (!matchRegex()) {
        return false;
    }

    cur = getNextToken(file, false);

    return cur.first == Slash;
}

bool Parser::matchRegex() {
    if (!matchRTerm()) {
        return false;
    }

    while (matchRTerm());

    return true;
}

bool Parser::matchRTerm() {
    if (!matchRClosure()) {
        return false;
    }

    while(matchRClosure());

    return true;
}

bool Parser::matchRClosure() {
    if (!matchRFactor()) {
        return false;
    }

    cur = getNextToken(file, false);
    /*if (cur.first == Star || cur.first == Plus || cur.first == Question) {
        cur = getNextToken(file, false);
    }*/
    return true;
}

bool Parser::matchRFactor() {
    if (cur.first == Character) {
        return true;
    }
    else if (cur.first == SetStart) {
        cur = getNextToken(file, true);
        if (cur.first != Id) {
            return false;
        }
        cur = getNextToken(file, false);
        return cur.first == SetEnd;
    }
    else if (cur.first == OpenParen) {
        cur = getNextToken(file, false);
        if (!matchRegex()) {
            return false;
        }
        return cur.first == CloseParen;
    }
    else {
        return false;
    }
}